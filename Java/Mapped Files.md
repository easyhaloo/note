

## Mapped Files

> 虽然我没有理由在大多数Java应用程序中使用直接内存，但它们是将文件映射到虚拟地址空间的基础 - 这一功能很少使用，但在您需要时非常有用。映射文件可让您随机访问 - 具体取决于您的访问模式 - 显着提升性能。为了理解原因，我们需要简单介绍一下Java文件I / O的工作方式。



### Java文件I / O的工作方式

首先需要理解Java文件类的工作方式，它们仅仅是操作系统文件调用的一层包装，当你的应用程序调用`read`时，你会执行`POSXIX`系统的同名调用。当操作系统要求读取数据时，它首先会查看磁盘缓存缓冲，看看你最近是否从同样的磁盘块中读取过数据。如果数据存在，就`"立即"`返回。如果不存在，操作系统将发起磁盘读取，并暂停程序直到数据可用。



比较重要的一点时，它是`immediately`，这并不意味着`quickly`：你需要去执行系统内核（OS Kernel）的读操作，这意味着你需要进行`"上下文切换（context switch）"`，从用户态切换到内核态。要进行此切换，首先需要从你的应用程序保存CPU寄存器和页表，然后从内核态中加载CPU寄存器和页表。当kernel调用完成，它将翻转这个过程。整个过程大概只是几微秒的事，但是频繁的访问文件，它们将会加起来。在最坏的情况下，操作系统调度将认为你的应用程序拥有充足的CPU，并在另一个程序运行时暂停它。



相比之下，使用memory-mapped file除非数据不在内存中，否则无需进进行系统调用。由于用于程序的RAM量大于用于磁盘缓冲区的RAM量，因此数据更可能存储在内存中。



当然，数据是否存在内存取决于许多事。最重要的是您是否按顺序访问数据：尽管JDK允许这样，但是使用映射缓存代替FileInputStream变得没有意义，因为你将经常等待从磁盘加载页面。



第二个问题是，你的文件有多大以及访问的随机性，如果你有一个数千兆字节的文件并从一个地方转移到另一个地方，那么你将一直等待从磁盘读取页面，但大多数程序都不会以真正随机的方式访问其数据，通常情况下，有一组块比其他块更频繁地被击中，并且这些块将保留在RAM中。例如，数据库服务器几乎在每个查询中读取索引的根节点，而不太频繁地访问各个数据块。



即使您没有通过内存映射文件（MMF）获得速度优势，也可以通过JavaBean风格的包装类访问它们来获得维护优势。这也将提高可测试性，因为您可以围绕已知测试数据构建缓冲区，而不涉及任何文件。



**Creating Mapping**

```java
File file = new File("/tmp/example.dat");
FileChannel channel = new RandomAccessFile(file, "r").getChannel();

ByteBuffer buf = channel.map(MapMode.READ_ONLY, 0L, file.length());
buf.order(ByteOrder.LITTLE_ENDIAN);

System.console().printf("data = %x", buf.getInt(0));
```

返回的`ByteBuffer`只是一个抽象，真正的返回是一个`MappedByteBuffer`，后者有两个特别的方法`load()`，`force()`

**load**

load()方法将尝试将所有的文件加载到RAM中，项目启动阶段加载降低了启动时间，但是增加了缺页中断的次数。这是一种体检优化，除非您的程序不断访问这些页面，否则操作系统可能会选择将它们用于其他内容，这意味着您无论如何都必须对它们进行错误处理。让操作系统完成其工作，并根据需要从磁盘加载页面。



**Read-Only & Read-Write**

Read-Only保证内存只读，这样可以防止意外写入，但更重要的是，这意味着该文件不会计入程序的提交费用。在64位计算机上，您可以映射TB级的只读文件。在大多数情况下，您不需要写访问权限：您有一个要处理的大型数据集，并且不想继续将其读取到堆内存中。

Read-Write 文件则需要更多的考虑，第一个重点考虑的事情是如果写入，内存管理者不想经常出现脏页写入磁盘，这意味着您的更改可能会在很长一段时间内保留在内存中，不会写入 - 如果断电，这将成为一个问题。要将脏页刷新到磁盘，请调用缓冲区的force（）方法。

这实际上是一个反模式：你不想在每次写入后刷新脏页，或者你将使程序受IO限制。相反，从数据库开发人员那里吸取教训，并将这些更改分组为原子单位（或者更好，如果您计划进行大量更新，请使用真实数据库）



**Garbage Collection of Direct/Mapped Buffers**

这带来了另一个话题：直接缓冲区和映射文件的非堆内存如何释放？毕竟，没有明确关闭或释放它们的方法。答案是他们像任何其他对象一样收集垃圾，但有一个转折：如果你没有足够的虚拟内存空间或保证用来分配直接缓冲区，"即使有足够的堆内存"，也会触发完整的GC。通常，这不会是一个问题：您可能不会比堆驻留对象更频繁地分配和释放直接缓冲区。但是，如果您认为完全GC出现在您不认为应该出现的情况下，请查看您的程序使用缓冲区



同样，当你使用直接缓冲区和映射文件时，你会看到一些更为深奥的OutOfMemoryError变种。

“Direct buffer memory”是一种比较普遍的，并且似乎表明OS强加的限制

同样有趣的是超出了RAM和swap可用的总内存：OutOfMemoryError甚至没有消息。



您可能会感到惊讶，第一次尝试在64位计算机上分配直接缓冲区时，如果有足够的RAM可用，则会出现OutOfMemoryError。您通常可以通过在启动JVM时传递以下选项来解决此问题：

- **-d64** 

  此选项指示JVM以64位模式运行。在撰写本文时，许多64位操作系统实际上都有32位JVM，因为32位JVM可能对“小”程序更有效。此选项仅针对Linux / Solaris JVM进行记录，并且文档中有关于何时以及如何调用64位JVM的许多警告。但它不会受到伤害。

- **-XX:MaxDirectMemorySize**

  此选项是一个触发垃圾回收的hack(这将收回任何无法访问的缓冲区)，该值采用正常的JVM内存指定(eg, 1024 for 1024 bytes, 1024m for 1024 megabytes, and 10g for 10 gigabytes)。`-XX`前缀表示它是“超级隐藏，未记录的，特定于OpenJDK的选项”之一，并且可能随时更改或删除。

```xml
java -XX:MaxDirectMemorySize=12g
```

如果您正在使用大缓冲区（直接缓冲区或内存映射文件），则还应使用-XX：+ UseLargePages选项

```xml
java -d64 -XX:MaxDIrectMemorySize=12g -XX:+UseLargePages
```

默认情况下，内存管理器以小块（通常为4k）将物理内存映射到虚拟地址空间。这意味着可以更有效地处理页面错误，因为读取或写入的数据更少。但是，小页面意味着内存管理硬件必须跟踪更多信息以将虚拟地址转换为物理地址。充其量，这意味着[TLB](http://en.wikipedia.org/wiki/Translation_lookaside_buffer)的使用效率较低，这使得每个内存访问速度变慢。在最坏的情况下，您将用完页表中的条目（报告为OutOfMemoryError）。



### 线程安全

缓冲区JavaDoc中明确涵盖了ByteBuffer线程安全性;简短的版本是缓冲区不是线程安全的。显然，在没有竞争条件的情况下，您不能使用来自多个线程的相对定位，但即使绝对定位也无法保证（无论您在查看实现类后如何看待）。幸运的是，解决方法很容易：为每个线程提供自己的缓冲区。



有两种方法可以让您从现有缓冲区创建一个新的缓冲区：duplicate（）和slice（）。我已经描述了后者：它创建了一个从当前缓冲区开始的新缓冲区。前者创建了一个覆盖整个原始的新缓冲区;它相当于将原始缓冲区的位置设置为零，然后调用slice（）。

这些方法的JavaDoc声明“[c]挂起到此缓冲区的内容将在新缓冲区中可见，反之亦然。”但是，我不认为这会考虑Java内存模型。为安全起见，请考虑具有与线程之间共享的对象等效的共享后备存储的缓冲区：并发访问可能会看到不同的值。当然，这只有在你写入缓冲区时才有意义;对于只读缓冲区，每个线程只需要一个唯一的缓冲区就足够了。



也就是说，你仍然有创建缓冲区的问题：你需要同步访问slice（）或duplicate（）调用。一种方法是在生成线程之前创建所有缓冲区。但是，这可能不方便，特别是如果您的缓冲区是另一个类的内部。另一种方法是使用ThreadLocal：

```java
public class ByteBufferThreadLocal
extends ThreadLocal<ByteBuffer>
{
    private ByteBuffer _src;

    public ByteBufferThreadLocal(ByteBuffer src)
    {
        _src = src;
    }

    @Override
    protected synchronized ByteBuffer initialValue()
    {
        return _src.duplicate();
    }
}
```

在此示例中，应用程序代码永远不会访问原始缓冲区。相反，它用作以同步方法生成副本的主服务器，并且应用程序使用这些副本。一旦线程完成，垃圾收集器将处理它使用的缓冲区，使主机保持不变