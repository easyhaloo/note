### MySQL数据类型优化



1. 更小通常更好

   数据类型越小(存0-200 可以使用tinyint unsigned)，占用的磁盘、内存哥CPU缓存都将变少。CPU的执行时间也将大大减少。

2. 简单就好

   简单数据类型的操作通常需要更少的CPU周期。例如：整数比字符操作代价更低，因为字符集和校队规则(排序规则)使字符比较比整型比较更复杂。

   应该使用MySQL内建的类型而不是字符串来存储日期和时间，另外一个是应该使用整型存储IP地址。

3. 尽量避免NULL

   查询中包可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节，在MyISAM里甚至还可能导致固定大小的索引(例如只有一个整数列的索引)变成可变大小的索引。

   InnoDB使用单独的位存储NULL值，所以对于稀疏数据(大部分值为NULL，少数为非NULL)有很好的空间效率。

在MySQL中，很多数据类型(大类型中的不同字类型，如字符串有char,varchar)可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度也不同，或者需要的物理空间也不同。

**例如：**DATETIME和TIMESTAMP列都可以存储相同类型的数据：时间和日期，精确到秒。然而TIMESTAMP只使用DATETIME一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力。



#### 数字类型

数字类型分为整数和实数。

##### 整数

整数的存储主要有:tinyint(8bit)，smallint(16bit)，mediumint(24bit)，int(32bit)，begint(64bit)。取值范围在-2<sup>(N-1)</sup>~2<sup>(N-1)</sup>-1。

整数类型有可选的unsigned，表示不允许为负数。这样可以在某些情况下，扩大存储倍数。

整数的计算一般使用64位的bigint整数，即使在32位的环境也是如此(一些聚合函数除外，它们使用double和decimal)。

MySQL可以为整数类型指定宽度，但是这个宽度指输出格式的长度，内部存储的范围跟此没有多大关系。

##### 实数

实数时带有小数部分的数字。主要的存储有：float(32bit)、double(64bit)、decimal。

cpu是不支持decimal的直接计算的，在MySQL内部是使用二进制的字符串(每4个字节存9个数字)和整数混合存储，例如decimal(18,9)整数9个数字，小数点后面9个数字，前面整型4个字节，后面字符串4个字节，小数点一个字节，一共9个字节。

#### 字符串类型

MySQL是支持多种字符串类型的，每个字符串列可以自定义字符集和排序规则，或者是校对规则(collation)

##### varchar & char

**varchar**类型用于存储可变长字符串，它比定长类型更节省空间，因为它仅使用必要的空间(ROW_FORMAT=FIXED例外)。

varchar 需要使用**1到2个额外字节**记录字符串的长度：如果列的最大长度小于或者等于255字节，则只使用一个字节表示，否则使用两个字节表示。当更新字符列时，可能会使该字符串变得比原来更长，这就导致需要做额外的工作。(MySQL在存储时，会保留末尾的空格)

**最佳实践：**如果字符串列的最大长度比平均长度大很多，列很少更新，使用了UTF-8字符集。

**char**类型是定长的，MySQL总是根据定义的字符串长度分配足够的空间，当存储char值时，MySQL会删除所有的末尾空格。

char适合存储很短的字符串，或者所有的值都接近同一个长度。

**最佳实践：**md5加密，对于经常变更的数据，比较短的列。

**比较：** varchar 会使用多余的空间来保存字符串长度，char会截取尾部的空格。

##### blog & text

blob和text都是用来存储很大的字符串数据的，它们分别采取二进制和字符的方式存储。

- 字符类型：tinytext，smalltext,text,mediumtext,longtext

- 二进制类型：tinyblob,smallblob,blob,mediumblob,longblob。

  MySQL会把blob和text值当作一个独立的对象处理，存储引擎在存储时常常会特殊处理。当两者太大时，InnoBD会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1～4个字节存储一个指针，然后在外部存储区域存储实际的值。

blob类型存储的是二进制数据，没有排序规则和字符集，而text有。

**排序也不同，**它们只对列的前max_sort_length字节排序。也不能使用索引。

使用blog和text查询时，应该尽量避免。因为使用这种大型的数据集会创建MyISAM磁盘临时表，即使是表中只有几行数据也是如此。这是一种昂贵的开销。可以使用一个技巧代替，在用到blob字段的地方都是用substr()进行截取长度(order by中也同样适用)，转换为字符串，这样就可以使用内存临时表。必须确保街区的字符串长度够短，不会使临时表大小超过max_heap_table_size或tmp_table_size。一旦超过，MySQL还是会将内存临时表转换为MyISAM磁盘临时表。

#### 枚举

有时候也可以使用枚举代替字符串。枚举列可以把雨鞋不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。MySQL在内部将每个值的列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的“查找表”。

枚举内部使用的存储的整数来排序的，而不是字符串类型。

枚举中的字符串时固定的，如果要修改属性，则必须删除表。

#### 日期&时间

MySQL时间类型采用：DATETIME 和TIMESTAMP

**DateTime**

可以保存1001~9999年，精度为秒。它把日期和时间封装成YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节存储。

**TimeStamp**

保存1970～2038，精度为秒，它和Unix时间戳相同。存储使用4个字节。MySQL提供`from_unixtime()`讲Unix时间戳转换为日期，并提供`unix_timestamp()`将日期转换成unix时间戳。TimeStamp的显示依赖时区。

TimeStamp默认值是`not null`，如果列设置TimeStamp后，每次插入更新都会更新为当前的时间戳。

 #### 位数据类型

MySQL中有少数几种存储类型使用紧凑的位存储数据。不管底层的存储格式是处理方式如何，从技术来说都是字符串类型。

**Bit**

bit列的最大长度是64位，bit的行为因存储引擎而异。MyISAM会打包存储所有的Bit列，所以bit存储17位，只需要3个字节即可。如果是其他存储引擎，为每个bit列使用一个足够存储的最小整数类型来存放，所以不能节省存储空间。

注意⚠️：MySQL中的位在数字的上下文场景下会将字符串转换成数字。例如:存储是a='0'， a+o=57.

**Set**

在MySQL内部以一些列打包的集合来表示，这样就有效地利用了存储空间。并且MySQL中有像FIND_IN_SET()和FIELD()这样的函数，方便地在查询中使用。它的主要缺点是改变列中的定义的代价较高，需要alert table，而且索引也无法生效。

**在整数列上进行按位操作**

一种替代set的方式是使用一个整数包装一些列的位，。

---

### Schema优化

---

#### 加快Alter Table操作的速度

MySQL的alter table操作的性能对大表来说是个大问题。MySQL大部分修改操作都是先用新的结构创建一个空表，然后再从旧表中查出所有数据插入新表，然后删除旧表。

针对上述问题，下面有两个常用的技巧：

- 现在一台不提供服务的机器上执行alter table操作，然后和提供服务的主库进行切换
- “影子拷贝”，先创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表。

当然也不是所有的alter table都会引起表的重建。所有的表结构数据都会存放在.frm文件中，所以为了加快修改速度，我们可以直接修改文件名即可达到类似的效果。

```mysql
alter column column_name set default xx;
```

*alter column*只是修改.frm文件而不会修改表数据。

还有一些类似的操作也是不需要重建表的：

- 移除一个列的`AUTO_INCREMENT `属性
- 增加、移除，或更改`ENUM`和`SET`常亮。如果移除的是已经有行数据用到其值的常量，查询将会返回一个空字符串值

##### 修改.frm文件

修改.frm的思想是：在将要修改的表结构上，重新创建一个新的表(.frm)，然后用它替换掉已经存在的那张表.frm文件。

1. 创建一张有相同结构的空表，并进行所需要的修改(例如增加ENUM常量)
2. 只想*flush tables with read lock*。这将关闭所有正在使用的表，并且禁止任何表被打开
3. 交换`.frm`文件
4. 只想*unlock tables*来释放步骤2中的读锁

##### 快速创建MyISAM索引

为了高效地栽入数据到MyISAM表中，有一个常用的技巧是先禁用索引、栽入数据，然后重启索引。

```mysql
alter table table_name disable keys;
-- load the data
alter table table_name enable keys;
```

此时，构建索引的工作被延迟到数据完全载入以后，这个时候可以通过排序来构建索引了。不仅快速，而且使得索引树的碎片更少、更紧凑。

**注意⚠️：** 该方式对唯一索引无效，因为disable keys 只对非唯一索引有效。MyISAM会在内存中构造唯一索引，并且为载入的每一行检查唯一性。一旦索引大小超过有效内存大小，载入操作就会变得越来越慢。

也可以使用前面修改文件的方式，当从备份中载入数据是很有用的。例如：当已经知道所有数据都是有效的并且没有必要做唯一性检查时就可以这么来操作。

具体的操作步骤：

1. 使用原始表的表结构创建一张新表，不包括索引
2. 载入数据到表中以构建.myd文件
3. 按照需要的结构创建另外一张空表，这次要包含索引。这会创建需要的.frm和.myi文件
4. 获取读锁并且刷新表
5. 重命名第二张表的.frm和.myi文件，让MySQL认为是第一张表的文件
6. 释放读锁
7. 使用repair table来重建表的索引。该操作会通过排序来构建所有的索引，包括唯一索引。









