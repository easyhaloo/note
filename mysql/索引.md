## 创建高效的索引

> 索引(在MySQL中也叫做“键(key)”)是存储引擎用于快速找到记录的一种数据结构。



### 索引基础

MySQL中存储引擎需要查找一行记录时，其现在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。

索引可以包含一个或者多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。创建一个包含两个列的索引和创建两个只包含一列的索引的大小是不相同的。



#### 索引类型

索引有很多类型，每种都有不同的应用场景。在MySQL中，索引是在存储引擎层而不是服务层实现。

##### B-Tree索引

这是一款使用B-Tree数据结构来存储数据的索引。

B-Tree通常意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同。

![image-20190719174653554](assets/image-20190719174653554.png)

**B+Tree:** 每个叶子结点都包含指向下一个叶子结点的指针，从而方便叶子结点的范围遍历。

B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始搜素。根节点的槽中存放了指向字节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层字节点，这些指针实际上定义了子节点页中值的上限和下限。

叶子节点比比较特别。它们的指针指向的是被索引的数据，而不是其他的节点页

B-Tree对索引列是顺序组织存储的，所以合适进行范围检索。

**可以使用B-Tree索引的查询类型**。B-Tree适用于全键值、键值范围或者键前缀查找。其中键前缀查重只适用于根据**最左前缀**的查找。

- *全值匹配*

  全值匹配指的是和索引中的所有列进行匹配

- *匹配最左前缀*

  如果一个索引中，包含多个列，则优先使用最左边的(第一列)

- *匹配列前缀*

  也可以只匹配某一列的值的开头部分

- *匹配范围值*

  可以匹配区间段，例如[1,8]，匹配这个区间段的

- *精确匹配某一列并范围匹配另外一列*

  当索引是多个列时，可以全匹配第一列，第二列进行范围匹配

- *只访问索引的查询*

  B-Tree通常可以支持“只访问索引的查询”，即查询只需要查询索引，而无需访问数据行。

因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的Order by操作。

**B-Tree索引的限制：**

- 如果不是按照索引的最左列开始查找，则无法使用索引

- 不能跳过索引中的列

- 如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引优化查找。例如有查询

  ```mysql
  select * from user where last_name = 'Smith' and first_name  like 'J%' and 
  dob = '1976-12-23'
  ```

  此时这个索引只能使用前两列。如果范围查询列的值数量有限，则可以使用多个等于来代替。

##### 哈希索引

哈希索引是基于哈希表实现，只有**精确匹配**索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希表条目中。

哈希索引的结构如下：

![image-20190719182052814](assets/image-20190719182052814.png)

注意每个槽点编号是顺序的，但是数据行不是。

因为索引自身只需要存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。当然它也是存在一定的限制：

- 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显
- 哈希索引数据不是按照索引值顺序存储的，所以无法用于排序
- 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值。例如，在数据列(A,B)上建立哈希索引，如果查询只有数据列A，则无法适应该索引
- 哈希索引只支持等值比较查询，包括=、IN()、<=>。也不支持任何范围查询，例如where price > 100
- 访问哈希索引数据非常快，除非有很多哈希冲突。当出现哈希冲突时，存储引擎必须遍历链表中的所有行指针，逐行进行比较，直到找到所有符合条件的行
- 如果哈希冲突很多的话，一些索引维护操作的代价变高。例如：如果在某个选择性很低的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值当链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大







