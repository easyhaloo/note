#  Part II. Servlet Applications

## 6. Java Configuration

Spring 3.1在Spring Framework中添加了对Java Configuration的一般支持。自Spring Security 3.2以来，Spring Security Java Configuration支持使用户无需使用任何XML即可轻松配置Spring Security。

如果您熟悉第7章安全命名空间配置，那么您应该发现它与安全Java配置支持之间有很多相似之处。



### 6.1 Hello Web Security Java Configuration

　第一步首先创建我们的Spring Security Java Configuration.该配置创建一个名为springSecurityFilterChain的Servlet过滤器，它负责应用程序中的所有安全性（保护应用程序URL，验证提交的用户名和密码，重定向到日志格式等）。您可以在下面找到Spring Security Java配置的最基本示例：

```java
import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.context.annotation.*;
import org.springframework.security.config.annotation.authentication.builders.*;
import org.springframework.security.config.annotation.web.configuration.*;

@EnableWebSecurity
public class WebSecurityConfig implements WebMvcConfigurer {

    @Bean
    public UserDetailsService userDetailsService() throws Exception {
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(User.withDefaultPasswordEncoder().username("user").password("password").roles("USER").build());
        return manager;
    }
}
```

这个配置虽然没什么，但是它做了很多。您可以在下面找到以下功能的摘要：

- 要求对访应用程序的每个URL进行身份验证
- 生成登录表单
- 允许您使用username和password通过表单进行基础的认证
- 允许你退出
- CSRF追踪预防
- Session Fixation 保护
- Security Header集成
  - 用于安全请求的HTTP严格传输安全性
  - X-Content-Type-Options集成
  - 缓存控制（稍后可由应用程序覆盖以允许缓存静态资源）
  - X-XSS-Protection 集成
  - X-Frame-Options集成有助于防止Clickjacking
- 集成以下Sevelt API:
  - [HttpServletRequest#getRemoteUser()](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser())
  - [HttpServletRequest.html#getUserPrincipal()](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal())
  - [HttpServletRequest.html#isUserInRole(java.lang.String)](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String))
  - [HttpServletRequest.html#login(java.lang.String, java.lang.String)](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login(java.lang.String, java.lang.String))
  - [HttpServletRequest.html#logout()](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout())

#### 6.1.1 AbstractSecurityWebApplicationInitializer

接下来注册`springSecurityFilterChain` 到war.这可以在Java配置中使用Spring的WebApplicationInitializer支持在Servlet 3.0+环境中完成。不出所料，Spring Security提供了一个基类AbstractSecurityWebApplicationInitializer，它将确保为您注册springSecurityFilterChain。我们使用AbstractSecurityWebApplicationInitializer的方式，因我们是否已经使用Spring或者Spring Security是我们应用程序中唯一的Spring组件而有所不同

#### 6.1.2 AbstractSecurityWebApplicationInitializer without Existing Spring

如果你没有使用Spring或者Spring MVC需要将WebSecurityConfig传递到超类中以确保获取配置。你可以在下面找到一个例子：

```java
import org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
    extends AbstractSecurityWebApplicationInitializer {

    public SecurityWebApplicationInitializer() {
        super(WebSecurityConfig.class);
    }
}
```

SecurityWebApplicationInitializer将执行以下操作：

- 自动注册springSecurityFilterChain Filter到每个URL
- 添加一个加载WebSecurityConfig的ContextLoaderListener。

#### 6.1.3 AbstractSecurityWebApplicationInitializer with Spring MVC

如果我们在应用程序的其他地方使用Spring，我们可能已经有了一个加载Spring Configuration的WebApplicationInitializer如果我们使用以前的配置，我们会收到错误。相反，我们应该使用现有的ApplicationContext注册Spring Security。例如，如果我们使用Spring MVC，我们的SecurityWebApplicationInitializer将如下所示：

```java
mport org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
    extends AbstractSecurityWebApplicationInitializer {

}
```

这只是为应用程序中的每个URL注册springSecurityFilterChain过滤器。之后，我们将确保在现有的ApplicationInitializer中加载WebSecurityConfig。例如，如果我们使用Spring MVC，它将被添加到getRootConfigClasses()中。

```java
public class MvcWebApplicationInitializer extends
        AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[] { WebSecurityConfig.class };
    }

    // ... other overrides ...
}
```

---

### 6.2 HttpSecurity

到目前为止，我们的WebSecurityConfig仅包含有关如何验证用户身份的信息。Spring Security如何知道我们要求所有用户都经过身份验证？Spring Security如何知道我们想要支持基于表单的身份验证？原因是WebSecurityConfigurerAdapter在configure（HttpSecurity http）方法中提供了一个默认配置，如下所示：

```java
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .anyRequest().authenticated()
            .and()
        .formLogin()
            .and()
        .httpBasic();
}
```

上面的默认配置：

- 确保对我们的应用程序的任何请求都要求用户进行身份验证
- 允许用户使用基于表单的登录进行身份验证
- 允许用户使用HTTP基本身份验证进行身份验证

您会注意到此配置与XML命名空间配置非常相似：

```xml
<http>
    <intercept-url pattern="/**" access="authenticated"/>
    <form-login />
    <http-basic />
</http>
```

使用and（）方法表示关闭XML标记的Java配置，这允许我们继续配置父标记。如果您阅读代码，它也是有道理的。我想配置授权请求并配置表单登录并配置HTTP基本身份验证。

---

### 6.3 Java Configuration and Form Login

当您被提示登录时，您可能想知道登录表单的来源,因为我们没有提到任何HTML文件或JSP,由于Spring Security的默认配置未明确设置登录页面的URL.Spring Security会根据启用的功能自动生成一个，并使用处理提交的登录的URL的标准值，登录后用户将发送到的默认目标URL等等。

自动生成的登录页面便于快速启动和运行，大多数应用程序都希望提供自己的登录页面。为此，我们可以更新我们的配置，如下所示：

```java
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .anyRequest().authenticated()
            .and()
        .formLogin()
            .loginPage("/login") //#1
            .permitAll();         // #2
}
```

**#1 更新的配置指定登录页面的位置。**

**#2 我们必须授予所有用户（即未经身份验证的用户）访问我们的登录页面的权限。formLogin（）。permitAll（）方法允许为与基于表单的登录相关联的所有URL授予对所有用户的访问权限。**

使用JSP实现当前配置的示例登录页面如下所示：

> 下面的登录页面代表我们当前的配置。如果某些默认设置不符合我们的需求，我们可以轻松更新配置。



```jsp
<c:url value="/login" var="loginUrl"/>
<form action="${loginUrl}" method="post">       
    <c:if test="${param.error != null}">        
        <p>
            Invalid username and password.
        </p>
    </c:if>
    <c:if test="${param.logout != null}">       
        <p>
            You have been logged out.
        </p>
    </c:if>
    <p>
        <label for="username">Username</label>
        <input type="text" id="username" name="username"/>  
    </p>
    <p>
        <label for="password">Password</label>
        <input type="password" id="password" name="password"/>  
    </p>
    <input type="hidden"                        
        name="${_csrf.parameterName}"
        value="${_csrf.token}"/>
    <button type="submit" class="btn">Log in</button>
</form>
```

- 对/ login URL的POST将尝试对用户进行身份验证
- 如果存在查询参数错误，则尝试进行身份验证并失败
- 如果存在查询参数注销，则表示用户已成功注销
- 用户名必须作为名为username的HTTP参数出现
- 密码必须作为名为password的HTTP参数出现



---

### 6.4 Authorize Requests

我们的示例仅要求用户进行身份验证，并且已针对应用程序中的每个URL进行了身份验证.我们可以通过向http.authorizeRequests（）方法添加多个子项来指定URL的自定义要求。例如：

```java
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()                                                                
            .antMatchers("/resources/**", "/signup", "/about").permitAll()                  
            .antMatchers("/admin/**").hasRole("ADMIN")                                      
            .antMatchers("/db/**").access("hasRole('ADMIN') and hasRole('DBA')")            
            .anyRequest().authenticated()                                                   
            .and()
        // ...
        .formLogin();
}
```

- http.authorizeRequests（）方法有多个子节点，每个匹配器按其声明的顺序进行考虑。
- 我们指定了任何用户都可以访问的多种URL模式。具体来说，如果URL以“/ resources /”开头，等于“/ signup”或等于“/ about”，则任何用户都可以访问请求。
- 任何以“/ admin /”开头的URL都将仅限于具有“ROLE_ADMIN”角色的用户。您会注意到，由于我们正在调用hasRole方法，因此我们不需要指定“ROLE_”前缀。
- 任何尚未匹配的URL只需要对用户进行身份验证

---

### 6.5 Handling Logouts

使用WebSecurityConfigurerAdapter时，会自动应用注销功能。默认情况下，访问URL / logout将通过以下方式记录用户：

- 使HTTP会话无效
- 清理已配置的任何RememberMe身份验证
- 清除SecurityContextHolder
- 重定向到/ login？logout

但是，与配置登录功能类似，您还可以使用各种选项来进一步自定义注销要求：

```java
protected void configure(HttpSecurity http) throws Exception {
    http
        .logout()      //#1                                                           
            .logoutUrl("/my/logout")     //#2                                                  
            .logoutSuccessUrl("/my/index")      //#3                                           
            .logoutSuccessHandler(logoutSuccessHandler)    //#4                            
            .invalidateHttpSession(true)   //#5                                                  
            .addLogoutHandler(logoutHandler)     //#6                                            
            .deleteCookies(cookieNamesToClear)       //#7                                
            .and()
        ...
}
```

- 提供注销支持。使用WebSecurityConfigurerAdapter时会自动应用此选项。

- 触发注销的URL（默认为/ logout）。如果启用了CSRF保护（默认），则该请求也必须是POST。有关更多信息，请参阅JavaDoc。
- 注销后重定向到的URL。默认为/ login？logout。有关更多信息，请参阅JavaDoc。
- 我们指定一个自定义的LogoutSuccessHandler。如果指定了此参数，则忽略logoutSuccessUrl（）。有关更多信息，请参阅JavaDoc
- 指定在注销时是否使HttpSession无效。默认情况下这是真的。配置封面下的SecurityContextLogoutHandler。有关更多信息，请参阅JavaDoc。
- 添加LogoutHandler。默认情况下，SecurityContextLogoutHandler被添加为最后一个LogoutHandler。
- 允许指定在注销成功时删除的cookie的名称。这是显式添加CookieClearingLogoutHandler的快捷方式。

> ===当然也可以使用XML Namespace表示法配置注销。有关更多详细信息，请参阅Spring Security XML Namespace部分中logout元素的文档。===

通常，为了自定义注销功能，您可以添加LogoutHandler和/或LogoutSuccessHandler实现。对于许多常见场景，在使用流畅的API时，这些处理程序将在幕后应用。



####  6.5.1 LogoutHandler

通常，LogoutHandler实现指示能够参与注销处理的类。预计将调用它们以进行必要的清理。因此，他们不应该抛出异常。提供了各种实现：

- [PersistentTokenBasedRememberMeServices](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/rememberme/PersistentTokenBasedRememberMeServices.html)
- [TokenBasedRememberMeServices](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/rememberme/TokenBasedRememberMeServices.html)
- [CookieClearingLogoutHandler](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/CookieClearingLogoutHandler.html)
- [CsrfLogoutHandler](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/csrf/CsrfLogoutHandler.html)
- [SecurityContextLogoutHandler](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html)
- [HeaderWriterLogoutHandler](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/HeaderWriterLogoutHandler.html)

代替直接提供LogoutHandler实现，流畅的API还提供了快捷方式，提供了相应的LogoutHandler实现。例如。deleteCookies（）允许指定在注销成功时删除的一个或多个cookie的名称。与添加CookieClearingLogoutHandler相比，这是一种快捷方式。



#### 6.5.2 LogoutSuccessHandler

LogoutFilter成功注销后调用LogoutSuccessHandler，处理例如重定向或转发到适当的目的地。请注意，该接口与LogoutHandler几乎相同，但可能引发异常。

提供以下实现：

- [SimpleUrlLogoutSuccessHandler](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/SimpleUrlLogoutSuccessHandler.html)
- HttpStatusReturningLogoutSuccessHandler

如上所述，您不需要直接指定SimpleUrlLogoutSuccessHandler。相反，流利API通过设置logoutSuccessUrl（）来提供快捷方式。这将在封面下设置SimpleUrlLogoutSuccessHandler。发生注销后，提供的URL将重定向到。默认为/ login？logout。



HttpStatusReturningLogoutSuccessHandler在REST API类型场景中可能很有趣。此LogoutSuccessHandler允许您提供要返回的纯HTTP状态代码，而不是在成功注销后重定向到URL。如果未配置，则默认情况下将返回状态代码200。



#### 6.5.3 Further Logout-Related References

- [Logout Handling](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#ns-logout)
- [Testing Logout](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#test-logout)
- [HttpServletRequest.logout()](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#servletapi-logout)
- [Section 10.5.4, “Remember-Me Interfaces and Implementations”](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#remember-me-impls)
- [Logging Out](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#csrf-logout) in section CSRF Caveats
- Section [Single Logout](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#cas-singlelogout) (CAS protocol)
- Documentation for the [logout element](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#nsa-logout) in the Spring Security XML Namespace section



---

### 6.6 OAuth 2.0 Client

OAuth 2.0客户端功能为OAuth 2.0授权框架中定义的客户端角色提供支持。

可以使用以下主要功能：

- [Authorization Code Grant](https://tools.ietf.org/html/rfc6749#section-1.3.1)
- [Client Credentials Grant](https://tools.ietf.org/html/rfc6749#section-1.3.4)
- Servlet环境的WebClient扩展（用于创建受保护的资源请求）

HttpSecurity.oauth2Client（）提供了许多用于自定义OAuth 2.0 Client的配置选项。以下代码显示了oauth2Client（）DSL可用的完整配置选项：

```
@EnableWebSecurity
public class OAuth2ClientSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Client()
                .clientRegistrationRepository(this.clientRegistrationRepository())
                .authorizedClientRepository(this.authorizedClientRepository())
                .authorizedClientService(this.authorizedClientService())
                .authorizationCodeGrant()
                    .authorizationRequestRepository(this.authorizationRequestRepository())
                    .authorizationRequestResolver(this.authorizationRequestResolver())
                    .accessTokenResponseClient(this.accessTokenResponseClient());
    }
}
```

#### 6.6.1 ClientRegistration

ClientRegistration表示在OAuth 2.0或OpenID Connect 1.0 Provider中注册的客户端。

客户端注册保存信息，例如客户端ID，客户端密钥，授权授权类型，重定向URI，范围，授权URI，令牌URI和其他详细信息。ClientRegistration及其属性定义如下：

```java
public final class ClientRegistration {
    private String registrationId;  
    private String clientId;    
    private String clientSecret;    
    private ClientAuthenticationMethod clientAuthenticationMethod;  
    private AuthorizationGrantType authorizationGrantType;  
    private String redirectUriTemplate; 
    private Set<String> scopes; 
    private ProviderDetails providerDetails;
    private String clientName;  

    public class ProviderDetails {
        private String authorizationUri;    
        private String tokenUri;    
        private UserInfoEndpoint userInfoEndpoint;
        private String jwkSetUri;   
        private Map<String, Object> configurationMetadata;  

        public class UserInfoEndpoint {
            private String uri; 
            private AuthenticationMethod authenticationMethod;  
            private String userNameAttributeName;   

        }
    }
}
```

- registrationId：唯一标识ClientRegistration的ID。

- clientId：客户端标识符。

- clientSecret：客户端密码。

- clientAuthenticationMethod：用于使用Provider对客户端进行身份验证的方法。支持的值是basic和post。

- authorizationGrantType：OAuth 2.0授权框架定义了四种授权授权类型。支持的值是authorization_code，implicit和client_credentials。

- redirectUriTemplate：客户端注册的重定向URI，授权服务器将终端用户的用户代理重定向到终端用户对客户端进行身份验证和授权访问之后.

- scopes：客户在授权请求流程中请求的范围，例如openid，电子邮件或配置文件。

- clientName：用于客户端的描述性名称。该名称可能在某些情况下使用，例如在自动生成的登录页面中显示客户端的名称时。

- authorizationUri：授权服务器的授权端点URI。

- tokenUri：授权服务器的令牌端点URI。

- jwkSetUri：用于从授权服务器检索JSON Web密钥（JWK）集的URI，其包含用于验证ID令牌的JSON Web签名（JWS）以及可选的UserInfo响应的加密密钥。

- configurationMetadata：OpenID提供程序配置信息。仅当配置了Spring Boot 2.x属性spring.security.oauth2.client.provider。[providerId] .issuerUri时，才能使用此信息。

- （userInfoEndpoint）uri：UserInfo端点URI，用于访问经过身份验证的最终用户的声明/属性。

- （userInfoEndpoint）authenticationMethod：将访问令牌发送到UserInfo端点时使用的身份验证方法。支持的值是**header**， **form** 和 **query**.。

- userNameAttributeName：UserInfo响应中返回的属性的名称，该属性引用最终用户的名称或标识符。

  #### 6.6.2 ClientRegistrationRepository

  ClientRegistrationRepository充当OAuth 2.0 / OpenID Connect 1.0 ClientRegistration的存储库。

  > 客户端注册信息最终由关联的授权服务器存储和拥有。此存储库提供检索主客户端注册信息的子集的功能，该子集与授权服务器一起存储。

  Spring Boot 2.x auto-configuration将spring.security.oauth2.client.registration。[registrationId]下的每个属性绑定到ClientRegistration的实例，然后组成ClientRegistrationRepository中的每个ClientRegistration实例。

  > ClientRegistrationRepository的默认实现是InMemoryClientRegistrationRepository。

  自动配置还将ClientRegistrationRepository注册为ApplicationContext中的@Bean，以便在应用程序需要时可以依赖注入。

  

  以下清单显示了一个示例：

  ```java
  @Controller
  public class OAuth2ClientController {
  
      @Autowired
      private ClientRegistrationRepository clientRegistrationRepository;
  
      @RequestMapping("/")
      public String index() {
          ClientRegistration googleRegistration =
              this.clientRegistrationRepository.findByRegistrationId("google");
  
          ...
  
          return "index";
      }
  }
  ```

  #### 6.6.3 OAuth2AuthorizedClient

  OAuth2AuthorizedClient是授权客户端的表示。当最终用户（资源所有者）已授权客户端访问其受保护资源时，将认为客户端已获得授权。

  OAuth2AuthorizedClient用于将OAuth2AccessToken（和可选的OAuth2RefreshToken）与ClientRegistration（客户端）和资源所有者相关联，后者是授予授权的Principal最终用户。

  #### 6.6.4 OAuth2AuthorizedClientRepository / OAuth2AuthorizedClientService

  OAuth2AuthorizedClientRepository负责在Web请求之间持久化OAuth2AuthorizedClient,然而，OAuth2AuthorizedClientService的主要作用是在应用程序级别管理OAuth2AuthorizedClient。

  从开发人员的角度来看，OAuth2AuthorizedClientRepository或OAuth2AuthorizedClientService提供了查找与客户端关联的OAuth2AccessToken的功能，以便可以使用它来启动受保护的资源请求。

  > Spring Boot 2.x自动配置在ApplicationContext中注册OAuth2AuthorizedClientRepository和/或OAuth2AuthorizedClientService @Bean。

  开发人员还可以在ApplicationContext中注册OAuth2AuthorizedClientRepository或OAuth2AuthorizedClientService @Bean（覆盖Spring Boot 2.x自动配置），以便能够查找与特定ClientRegistration（客户端）关联的OAuth2AccessToken。

以下清单显示了一个示例：

```java
@Controller
public class OAuth2LoginController {

    @Autowired
    private OAuth2AuthorizedClientService authorizedClientService;

    @RequestMapping("/userinfo")
    public String userinfo(OAuth2AuthenticationToken authentication) {
        // authentication.getAuthorizedClientRegistrationId() returns the
        // registrationId of the Client that was authorized during the oauth2Login() flow
        OAuth2AuthorizedClient authorizedClient =
            this.authorizedClientService.loadAuthorizedClient(
                authentication.getAuthorizedClientRegistrationId(),
                authentication.getName());

        OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

        ...

        return "userinfo";
    }
}
```

#### 6.6.5 RegisteredOAuth2AuthorizedClient

@ RegisteredOAuth2AuthorizedClient注解提供了将方法参数解析为OAuth2AuthorizedClient类型的参数值的功能。与通过OAuth2AuthorizedClientService查找OAuth2AuthorizedClient相比，这是一种方便的替代方法。

```java
@Controller
public class OAuth2LoginController {

    @RequestMapping("/userinfo")
    public String userinfo(@RegisteredOAuth2AuthorizedClient("google") OAuth2AuthorizedClient authorizedClient) {
        OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

        ...

        return "userinfo";
    }
}
```

@ RegisteredOAuth2AuthorizedClient注解由OAuth2AuthorizedClientArgumentResolver处理，并提供以下功能：

- 如果客户端尚未获得授权，将自动请求OAuth2AccessToken。
  - 对于authorization_code，这涉及触发授权请求重定向以启动流
  - 对于client_credentials，使用DefaultClientCredentialsTokenResponseClient直接从令牌端点获取访问令牌

#### 6.6.6 AuthorizationRequestRepository

AuthorizationRequestRepository负责从启动授权请求到收到授权响应时（回调）的持久性OAuth2AuthorizationRequest。

> OAuth2AuthorizationRequest用于关联和验证授权响应。

AuthorizationRequestRepository的默认实现是HttpSessionOAuth2AuthorizationRequestRepository，它将OAuth2AuthorizationRequest存储在HttpSession中。

如果您想提供在Cookie中存储OAuth2AuthorizationRequest属性的AuthorizationRequestRepository的自定义实现，您可以按以下示例所示进行配置：

```java
@EnableWebSecurity
public class OAuth2ClientSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Client()
                .authorizationCodeGrant()
                    .authorizationRequestRepository(this.cookieAuthorizationRequestRepository())
                    ...
    }

    private AuthorizationRequestRepository<OAuth2AuthorizationRequest> cookieAuthorizationRequestRepository() {
        return new HttpCookieOAuth2AuthorizationRequestRepository();
    }
}
```

#### 6.6.7 OAuth2AuthorizationRequestResolver

OAuth2AuthorizationRequestResolver的主要作用是从提供的Web请求中解析OAuth2AuthorizationRequest。默认实现DefaultOAuth2AuthorizationRequestResolver匹配（默认）路径/ oauth2 / authorization / {registrationId}，提取registrationId并使用它为关联的ClientRegistration构建OAuth2AuthorizationRequest。

OAuth2AuthorizationRequestResolver可以实现的主要用例之一是能够使用高于OAuth 2.0授权框架中定义的标准参数的附加参数来自定义授权请求。



例如，OpenID Connect为授权代码流定义了额外的OAuth 2.0请求参数，这些参数扩展自OAuth 2.0授权框架中定义的标准参数。其中一个扩展参数是prompt(提示)参数。

> 可选的。空格分隔，区分大小写的ASCII字符串值列表，指定授权服务器是否提示最终用户进行重新认证和同意。定义的值为：none，login，consent，select_account

以下示例显示如何通过包含请求参数prompt = consent来实现自定义oauth2Login（）的授权请求的OAuth2AuthorizationRequestResolver。

```java
@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private ClientRegistrationRepository clientRegistrationRepository;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .anyRequest().authenticated()
                .and()
            .oauth2Login()
                .authorizationEndpoint()
                    .authorizationRequestResolver(
                            new CustomAuthorizationRequestResolver(
                                    this.clientRegistrationRepository));    
    }
}

public class CustomAuthorizationRequestResolver implements OAuth2AuthorizationRequestResolver {
    private final OAuth2AuthorizationRequestResolver defaultAuthorizationRequestResolver;

    public CustomAuthorizationRequestResolver(
            ClientRegistrationRepository clientRegistrationRepository) {

        this.defaultAuthorizationRequestResolver =
                new DefaultOAuth2AuthorizationRequestResolver(
                        clientRegistrationRepository, "/oauth2/authorization");
    }

    @Override
    public OAuth2AuthorizationRequest resolve(HttpServletRequest request) {
        OAuth2AuthorizationRequest authorizationRequest =
                this.defaultAuthorizationRequestResolver.resolve(request);  

        return authorizationRequest != null ?   
                customAuthorizationRequest(authorizationRequest) :
                null;
    }

    @Override
    public OAuth2AuthorizationRequest resolve(
            HttpServletRequest request, String clientRegistrationId) {

        OAuth2AuthorizationRequest authorizationRequest =
                this.defaultAuthorizationRequestResolver.resolve(
                    request, clientRegistrationId);    

        return authorizationRequest != null ?   
                customAuthorizationRequest(authorizationRequest) :
                null;
    }

    private OAuth2AuthorizationRequest customAuthorizationRequest(
            OAuth2AuthorizationRequest authorizationRequest) {

        Map<String, Object> additionalParameters =
                new LinkedHashMap<>(authorizationRequest.getAdditionalParameters());
        additionalParameters.put("prompt", "consent");  

        return OAuth2AuthorizationRequest.from(authorizationRequest)    
                .additionalParameters(additionalParameters) 
                .build();
    }
}
```

- 配置自定义OAuth2AuthorizationRequestResolver
- 尝试使用DefaultOAuth2AuthorizationRequestResolver解析OAuth2AuthorizationRequest
- 如果解析了OAuth2AuthorizationRequest而不是返回自定义版本，则返回null
- 将自定义参数添加到现有OAuth2AuthorizationRequest.additionalParameters
- 创建默认OAuth2AuthorizationRequest的副本，该副本返回OAuth2AuthorizationRequest.Builder以进行进一步修改
- 覆盖默认的additionalParameters

> OAuth2AuthorizationRequest.Builder.build（）构造OAuth2AuthorizationRequest.authorizationRequestUri，它代表完整的授权请求URI，包括使用application / x-www-form-urlencoded格式的所有查询参数。

上面的示例显示了在标准参数之上添加自定义参数的常见用例。但是，如果您需要删除或更改标准参数或者您的要求更高级，则可以通过简单地覆盖OAuth2AuthorizationRequest.authorizationRequestUri属性来完全控制构建授权请求URI。



以下示例显示了上一示例中customAuthorizationRequest（）方法的变体，覆盖了OAuth2AuthorizationRequest.authorizationRequestUri属性。



```java
private OAuth2AuthorizationRequest customAuthorizationRequest(
        OAuth2AuthorizationRequest authorizationRequest) {

    String customAuthorizationRequestUri = UriComponentsBuilder
            .fromUriString(authorizationRequest.getAuthorizationRequestUri())
            .queryParam("prompt", "consent")
            .build(true)
            .toUriString();

    return OAuth2AuthorizationRequest.from(authorizationRequest)
            .authorizationRequestUri(customAuthorizationRequestUri)
            .build();
}
```



#### 6.6.8 OAuth2AccessTokenResponseClient

OAuth2AccessTokenResponseClient的主要作用是在授权服务器的令牌端点处交换访问令牌凭据的授权授予凭据。



用于authorization_code授权的OAuth2AccessTokenResponseClient的默认实现是DefaultAuthorizationCodeTokenResponseClient，它使用RestOperations在令牌端点处交换访问令牌的授权代码。



DefaultAuthorizationCodeTokenResponseClient非常灵活，因为它允许您自定义令牌请求的预处理和/或令牌响应的后处理。

如果您需要自定义令牌请求的预处理,你可以提供DefaultAuthorizationCodeTokenResponseClient.setRequestEntityConverter（）带有自定义 Converter <OAuth2AuthorizationCodeGrantRequest，RequestEntity <？>>。默认实现OAuth2AuthorizationCodeGrantRequestEntityConverter构建标准OAuth 2.0访问令牌请求的RequestEntity表示。但是，提供自定义转换器将允许您扩展标准令牌请求并添加自定义参数。



>自定义转换器必须返回OAuth 2.0访问令牌请求的有效RequestEntity表示，该表示由预期的OAuth 2.0提供程序理解。

另一方面，如果您需要自定义令牌响应的后处理，您需要使用自定义配置的RestOperations提供DefaultAuthorizationCodeTokenResponseClient.setRestOperations（）。默认的RestOperations配置如下：

```java
RestTemplate restTemplate = new RestTemplate(Arrays.asList(
        new FormHttpMessageConverter(),
        new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());
```

> 发送OAuth 2.0访问令牌请求时，需要使用Spring MVC FormHttpMessageConverter

OAuth2AccessTokenResponseHttpMessageConverter是OAuth 2.0访问令牌响应的HttpMessageConverter，OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter（），带有自定义Converter <Map <String，String>，OAuth2AccessTokenResponse>，用于将OAuth 2.0访问令牌响应参数转换为OAuth2AccessTokenResponse。



OAuth2ErrorResponseErrorHandler是一个ResponseErrorHandler，可以处理OAuth 2.0错误（400 Bad Request）。它使用OAuth2ErrorHttpMessageConverter将OAuth 2.0 Error参数转换为OAuth2Error。



无论您是自定义DefaultAuthorizationCodeTokenResponseClient还是提供自己的OAuth2AccessTokenResponseClient实现，您都需要对其进行配置，如以下示例所示：

```java
@EnableWebSecurity
public class OAuth2ClientSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Client()
                .authorizationCodeGrant()
                    .accessTokenResponseClient(this.customAccessTokenResponseClient())
                    ...
    }

    private OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> customAccessTokenResponseClient() {
        ...
    }
}
```

---

###  6.7 OAuth 2.0 Login

Auth 2.0登录功能为应用程序提供了使用OAuth 2.0提供程序（例如GitHub）或OpenID Connect 1.0提供程序（例如Google）上的现有帐户登录应用程序的功能。OAuth 2.0 Login实现了用例：“使用Google登录”或“使用GitHub登录”。

> OAuth 2.0登录是使用授权代码授权实现的，如OAuth 2.0授权框架和OpenID Connect Core 1.0中所指定。

#### 6.7.1 Spring Boot 2.x Sample

Spring Boot 2.x为OAuth 2.0登录带来了完整的自动配置功能。本部分介绍如何使用Google作为身份验证提供程序配置OAuth 2.0登录示例，并介绍以下主题：

- [Initial setup](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2login-sample-initial-setup)
- [Setting the redirect URI](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2login-sample-redirect-uri)
- [Configure application.yml](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2login-sample-application-config)
- [Boot up the application](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2login-sample-boot-application)

#### Initial setup

要使用Google的OAuth 2.0身份验证系统进行登录，您必须在Google API控制台中设置项目以获取OAuth 2.0凭据。

> Google的OAuth 2.0身份验证实施符合OpenID Connect 1.0规范，并通过OpenID认证。

按照 [OpenID Connect](https://developers.google.com/identity/protocols/OpenIDConnect)页面上的说明操作，从“设置OAuth 2.0”部分开始。

完成“获取OAuth 2.0凭据”说明后，您应该拥有一个新的OAuth客户端，其凭据包含客户端ID和客户端密钥。

#### Setting the redirect URI

重定向URI是应用程序中的路径，最终用户的用户代理在通过Google进行身份验证并在“同意”页面上授予了对OAuth客户端（在上一步中创建）的访问权限后重定向回的路径。

在“设置重定向URI”子部分中，确保将“**Authorized redirect URIs**”字段设置为`http://localhost:8080/login/oauth2/code/google`.

> 默认重定向URI模板是`{baseUrl}/login/oauth2/code/{registrationId}`.。registrationId是[ClientRegistration](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2Client-client-registration).的唯一标识符。

#### Configure application.yml

既然您有一个新的OAuth客户端与Google，您需要配置应用程序以使用OAuth客户端进行身份验证流程。为此：

1. 转到application.yml并设置以下配置：

   ```yaml
   spring:
     security:
       oauth2:
         client:
           registration:    ##1
             google:    ##2
               client-id: google-client-id
               client-secret: google-client-secret
   ```

   - spring.security.oauth2.client.registration是OAuth客户端属性的基本属性前缀。
   - 基本属性前缀后面是ClientRegistration的ID，例如google。

2. 使用您之前创建的OAuth 2.0凭据替换client-id和client-secret属性中的值。

#### Boot up the application

启动Spring Boot 2.x示例并转到`http://localhost:8080`. 。然后，您将被重定向到默认的自动生成的登录页面，该页面显示Google的链接。

点击Google链接，然后您将重定向到Google进行身份验证。

使用您的Google帐户凭据进行身份验证后，显示给您的下一页是“同意”屏幕。“同意”屏幕会要求您允许或拒绝访问您之前创建的OAuth客户端。单击“允许”以授权OAuth客户端访问您的电子邮件地址和基本配置文件信息。



此时，OAuth客户端从[UserInfo Endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo) 检索您的电子邮件地址和基本配置文件信息，并建立经过身份验证的会话。

#### 6.7.2 Spring Boot 2.x Property Mappings

下表概述了Spring Boot 2.x OAuth客户端属性到ClientRegistration属性的映射。

| Spring Boot 2.x                                              | ClientRegistration                                       |
| ------------------------------------------------------------ | -------------------------------------------------------- |
| `spring.security.oauth2.client.registration.*[registrationId]*` | `registrationId`                                         |
| `spring.security.oauth2.client.registration.*[registrationId]*.client-id` | `clientId`                                               |
| `spring.security.oauth2.client.registration.*[registrationId]*.client-secret` | `clientSecret`                                           |
| `spring.security.oauth2.client.registration.*[registrationId]*.client-authentication-method` | `clientAuthenticationMethod`                             |
| `spring.security.oauth2.client.registration.*[registrationId]*.authorization-grant-type` | `authorizationGrantType`                                 |
| `spring.security.oauth2.client.registration.*[registrationId]*.redirect-uri` | `redirectUriTemplate`                                    |
| `spring.security.oauth2.client.registration.*[registrationId]*.scope` | `scopes`                                                 |
| `spring.security.oauth2.client.registration.*[registrationId]*.client-name` | `clientName`                                             |
| `spring.security.oauth2.client.provider.*[providerId]*.authorization-uri` | `providerDetails.authorizationUri`                       |
| `spring.security.oauth2.client.provider.*[providerId]*.token-uri` | `providerDetails.tokenUri`                               |
| `spring.security.oauth2.client.provider.*[providerId]*.jwk-set-uri` | `providerDetails.jwkSetUri`                              |
| `spring.security.oauth2.client.provider.*[providerId]*.user-info-uri` | `providerDetails.userInfoEndpoint.uri`                   |
| `spring.security.oauth2.client.provider.*[providerId]*.user-info-authentication-method` | `providerDetails.userInfoEndpoint.authenticationMethod`  |
| `spring.security.oauth2.client.provider.*[providerId]*.userNameAttribute` | `providerDetails.userInfoEndpoint.userNameAttributeName` |



#### 6.7.3 CommonOAuth2Provider

CommonOAuth2Provider为众多知名提供商预定义了一组默认客户端属性：Google，GitHub，Facebook和Okta。

例如，authorization-uri，token-uri和user-info-uri对于Provider不会经常更改。因此，提供默认值以减少所需配置是有意义的。

如前所述，当我们配置[Google客户端](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2login-sample-application-config)时，只需要client-id和client-secret属性。

以下清单显示了一个示例：

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: google-client-id
            client-secret: google-client-secret
```

> 客户端属性的自动默认无缝地在这里工作，因为registrationId（google）与CommonOAuth2Provider中的`GOOGLE` `enum` （不区分大小写）匹配。

对于您可能希望指定其他registrationId（例如google-login）的情况，您仍然可以通过配置provider属性来利用客户端属性的自动默认。

以下清单显示了一个示例：

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          google-login:  #1
            provider: google #2    
            client-id: google-client-id
            client-secret: google-client-secret
```

- registrationId设置为google-login。
- provider属性设置为google，它将利用CommonOAuth2Provider.GOOGLE.getBuilder（）中设置的客户端属性的自动默认

#### 6.7.4 Configuring Custom Provider Properties

有些OAuth 2.0提供程序支持多租户，这会导致每个租户（或子域）使用不同的协议端点。

例如，向Okta注册的OAuth客户端被分配给特定的子域并拥有自己的协议端点。

对于这些情况，Spring Boot 2.x提供了以下用于配置自定义提供程序属性的基本属性：`spring.security.oauth2.client.provider.*[providerId]`.

以下清单显示了一个示例：

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
        provider:
          okta:  #1
            authorization-uri: https://your-subdomain.oktapreview.com/oauth2/v1/authorize
            token-uri: https://your-subdomain.oktapreview.com/oauth2/v1/token
            user-info-uri: https://your-subdomain.oktapreview.com/oauth2/v1/userinfo
            user-name-attribute: sub
            jwk-set-uri: https://your-subdomain.oktapreview.com/oauth2/v1/keys
```

- 基本属性（spring.security.oauth2.client.provider.okta）允许自定义配置协议端点位置。

####  6.7.5 Overriding Spring Boot 2.x Auto-configuration

OAuth客户端支持的Spring Boot 2.x自动配置类是OAuth2ClientAutoConfiguration

它执行以下任务：

- 从配置的OAuth客户端属性注册由ClientRegistration组成的ClientRegistrationRepository @Bean。
- 提供WebSecurityConfigurerAdapter @Configuration并通过httpSecurity.oauth2Login（）启用OAuth 2.0登录。

如果您需要根据具体要求覆盖自动配置，可以通过以下方式执行此操作：

- [Register a ClientRegistrationRepository @Bean](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2login-register-clientregistrationrepository-bean)
- [Provide a WebSecurityConfigurerAdapter](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2login-provide-websecurityconfigureradapter)
- [Completely Override the Auto-configuration](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2login-completely-override-autoconfiguration)

#### Register a ClientRegistrationRepository @Bean

以下示例显示如何注册ClientRegistrationRepository @Bean：

```java
@Configuration
public class OAuth2LoginConfig {

    @Bean
    public ClientRegistrationRepository clientRegistrationRepository() {
        return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
    }

    private ClientRegistration googleClientRegistration() {
        return ClientRegistration.withRegistrationId("google")
            .clientId("google-client-id")
            .clientSecret("google-client-secret")
            .clientAuthenticationMethod(ClientAuthenticationMethod.BASIC)
            .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
            .redirectUriTemplate("{baseUrl}/login/oauth2/code/{registrationId}")
            .scope("openid", "profile", "email", "address", "phone")
            .authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
            .tokenUri("https://www.googleapis.com/oauth2/v4/token")
            .userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
            .userNameAttributeName(IdTokenClaimNames.SUB)
            .jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
            .clientName("Google")
            .build();
    }
}
```

####  Provide a WebSecurityConfigurerAdapter

以下示例说明如何使用@EnableWebSecurity提供WebSecurityConfigurerAdapter并通过httpSecurity.oauth2Login（）启用OAuth 2.0登录：

```java
@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .anyRequest().authenticated()
                .and()
            .oauth2Login();
    }
}
```

#### Completely Override the Auto-configuration

以下示例说明如何通过注册ClientRegistrationRepository @Bean并提供WebSecurityConfigurerAdapter来完全覆盖自动配置。

```java
@Configuration
public class OAuth2LoginConfig {

    @EnableWebSecurity
    public static class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                .authorizeRequests()
                    .anyRequest().authenticated()
                    .and()
                .oauth2Login();
        }
    }

    @Bean
    public ClientRegistrationRepository clientRegistrationRepository() {
        return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
    }

    private ClientRegistration googleClientRegistration() {
        return ClientRegistration.withRegistrationId("google")
            .clientId("google-client-id")
            .clientSecret("google-client-secret")
            .clientAuthenticationMethod(ClientAuthenticationMethod.BASIC)
            .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
            .redirectUriTemplate("{baseUrl}/login/oauth2/code/{registrationId}")
            .scope("openid", "profile", "email", "address", "phone")
            .authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
            .tokenUri("https://www.googleapis.com/oauth2/v4/token")
            .userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
            .userNameAttributeName(IdTokenClaimNames.SUB)
            .jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
            .clientName("Google")
            .build();
    }
}
```

#### 6.7.6 Java Configuration without Spring Boot 2.x

如果您无法使用Spring Boot 2.x并且想要在CommonOAuth2Provider中配置一个预定义的提供程序（例如，Google），请应用以下配置：

```java
@Configuration
public class OAuth2LoginConfig {

    @EnableWebSecurity
    public static class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                .authorizeRequests()
                    .anyRequest().authenticated()
                    .and()
                .oauth2Login();
        }
    }

    @Bean
    public ClientRegistrationRepository clientRegistrationRepository() {
        return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
    }

    @Bean
    public OAuth2AuthorizedClientService authorizedClientService(
            ClientRegistrationRepository clientRegistrationRepository) {
        return new InMemoryOAuth2AuthorizedClientService(clientRegistrationRepository);
    }

    @Bean
    public OAuth2AuthorizedClientRepository authorizedClientRepository(
            OAuth2AuthorizedClientService authorizedClientService) {
        return new AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService);
    }

    private ClientRegistration googleClientRegistration() {
        return CommonOAuth2Provider.GOOGLE.getBuilder("google")
            .clientId("google-client-id")
            .clientSecret("google-client-secret")
            .build();
    }
}
```

#### 6.7.7 Additional Resources

以下附加资源描述了高级配置选项：

- [OAuth 2.0 Login Page](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2login-advanced-login-page)
- [Redirection Endpoint](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2login-advanced-redirection-endpoint)
- [UserInfo Endpoint:](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2login-advanced-userinfo-endpoint)
  - [Mapping User Authorities](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2login-advanced-map-authorities)
  - [Configuring a Custom OAuth2User](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2login-advanced-custom-user)
  - [OAuth 2.0 UserService](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2login-advanced-oauth2-user-service)
  - [OpenID Connect 1.0 UserService](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2login-advanced-oidc-user-service)

---

### 6.8 OAuth 2.0 Resource Server

Spring Security支持使用[JWT](https://tools.ietf.org/html/rfc7519)-编码的OAuth 2.0承载令牌保护端点([Bearer Tokens](https://tools.ietf.org/html/rfc6750.html).)。

在应用程序将其权限管理联合到授权服务器（例如，Okta或Ping Identity）的情况下，这很方便。资源服务器可以查询此授权服务器，以便在提供请求时验证权限。

> 可以在[**OAuth 2.0 Resource Server Servlet sample**](https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2resourceserver).示例中找到完整的工作示例

####  6.8.1 Dependencies

大多数资源服务器支持都收集到spring-security-oauth2-resource-server中.然而，对解码和验证JWT的支持是spring-security-oauth2-jose，这意味着为了拥有支持JWT编码的承载令牌的工作资源服务器，两者都是必需的。

#### 6.8.2 Minimal Configuration

使用Spring Boot时，将应用程序配置为资源服务器包含两个基本步骤。首先，包括所需的依赖项，然后指出授权服务器的位置。

#### Specifying the Authorization Server

要指定要使用的授权服务器，只需执行以下操作：

```yaml
security:
  oauth2:
    resourceserver:
      jwt:
        issuer-uri: https://idp.example.com
```

其中https://idp.example.com是授权服务器将颁发的JWT令牌的iss声明中包含的值。资源服务器将使用此属性进一步自我配置，发现授权服务器的公钥，并随后验证传入的JWT。

> 要使用issuer-uri属性，https://idp.example.com/.well-known/openid-configuration必须是授权服务器支持的端点。此端点称为提供者配置端点。

####  Startup Expectations

使用此属性和这些依赖项时，Resource Server将自动配置自身以验证JWT编码的承载令牌。

它通过确定性的启动过程实现了这一点：

- 命中Provider Configuration端点，https：//idp.example.com/.well-known/openid-configuration，处理jwks_url属性的响应
- 配置验证策略以查询jwks_url以获取有效的公钥
- 配置验证策略以针对https://idp.example.com验证每个JWTs iss声明。

此过程的结果是授权服务器必须启动并接收请求才能使Resource Server成功启动。

> 如果授权服务器在资源服务器查询时关闭（给定适当的超时），则启动将失败。

#### Runtime Expectations

启动应用程序后，Resource Server将尝试处理包含Authorization：Bearer标头的任何请求：

```
GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this
```

只要指示此方案，资源服务器将尝试根据承载令牌规范处理请求。

给定格式良好的JWT令牌，资源服务器将:

- 根据在启动期间从jwks_url端点获取的公钥验证其签名，并与JWTs头匹配
- 验证JWTs exp和nbf时间戳以及JWTs iss声明，以及
- 将每个范围映射到具有前缀SCOPE_的权限。

> 当授权服务器提供新密钥时，Spring Security将自动轮换用于验证JWT令牌的密钥。

认情况下，生成的Authentication＃getPrincipal是Spring Security Jwt对象，Authentication＃getName映射到JWT的子属性（如果存在）。

从这里开始，考虑跳转到：

[How to Configure without Tying Resource Server startup to an authorization server’s availability](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2resourceserver-jwkseturi)

[How to Configure without Spring Boot](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2resourceserver-sansboot)



#### 6.8.3 Specifying the Authorization Server JWK Set Uri Directly

如果授权服务器不支持Provider Configuration端点，或者Resource Server必须能够独立于授权服务器启动，则可以将issuer-uri交换为jwk-set-uri：

```java
security:
  oauth2:
    resourceserver:
      jwt:
        jwk-set-uri: https://idp.example.com/.well-known/jwks.json
```

> JWK Set uri不是标准化的，但通常可以在授权服务器的文档中找到

因此，资源服务器不会在启动时ping授权服务器。但是，它也将不再验证JWT中的iss声明（因为资源服务器不再知道发行者的值应该是什么）。

> 此属性也可以直接在[DSL](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#oauth2resourceserver-jwkseturi-dsl).上提供。

#### 6.8.4 Overriding or Replacing Boot Auto Configuration

Spring Boot代表两个@Bean，它们代表资源服务器生成。

第一个是WebSecurityConfigurerAdapter，它将应用程序配置为资源服务器：

```java
protected void configure(HttpSecurity http) {
    http
        .authorizeRequests()
            .anyRequest().authenticated()
            .and()
        .oauth2ResourceServer()
            .jwt();
}
```

如果应用程序未公开WebSecurityConfigurerAdapter bean，则Spring Boot将公开上述默认值。

替换它就像在应用程序中公开bean一样简单：

```java
@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests()
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_message:read")
                .anyRequest().authenticated()
                .and()
            .oauth2ResourceServer()
                .jwt()
                    .jwtAuthenticationConverter(myConverter());
    }
}
```

以上内容需要消息的范围：读取以/ messages /开头的任何URL。

oauth2ResourceServer DSL上的方法也将覆盖或替换自动配置。

例如，第二个@Bean Spring Boot创建的是一个JwtDecoder，它将String标记解码为Jwt的验证实例：

```java
@Bean
public JwtDecoder jwtDecoder() {
    return JwtDecoders.fromOidcIssuerLocation(issuerUri);
}
```

如果应用程序没有公开JwtDecoder bean，那么Spring Boot将公开上面的默认bean。

并且可以使用jwkSetUri（）覆盖其配置或使用decoder（）替换它的配置。

#### Using `jwkSetUri()`

授权服务器的JWK Set Uri可以配置为配置属性，也可以在DSL中提供：

```java
@EnableWebSecurity
public class DirectlyConfiguredJwkSetUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests()
                .anyRequest().authenticated()
                .and()
            .oauth2ResourceServer()
                .jwt()
                    .jwkSetUri("https://idp.example.com/.well-known/jwks.json");
    }
}
```

使用jwkSetUri（）优先于任何配置属性。

#### Using `decoder()`

比jwkSetUri（）更强大的是decoder（），它将完全取代JwtDecoder的任何Boot自动配置：

```java
@EnableWebSecurity
public class DirectlyConfiguredJwkSetUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests()
                .anyRequest().authenticated()
                .and()
            .oauth2ResourceServer()
                .jwt()
                    .decoder(myCustomDecoder());
    }
}
```

当需要更深层次的配置（如验证，映射或请求超时）时，这很方便。

#### Exposing a `JwtDecoder` `@Bean`

或者，暴露JwtDecoder @Bean与decoder（）具有相同的效果：

```java
@Bean
public JwtDecoder jwtDecoder() {
    return new NimbusJwtDecoder(JwtProcessors.withJwkSetUri(jwkSetUri).build());
}
```

#### 6.8.5 Configuring Authorization

从OAuth 2.0授权服务器发出的JWT通常具有范围或scp属性，指示已授予的范围（或权限），例如：

{ …, "scope" : "messages contacts"}

在这种情况下，资源服务器将尝试将这些范围强制转换为已授权的权限列表，并在每个范围前添加字符串“SCOPE_”。

这意味着要使用从JWT派生的作用域保护端点或方法，相应的表达式应包含此前缀：

```java
@EnableWebSecurity
public class DirectlyConfiguredJwkSetUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests()
                .mvcMatchers("/contacts/**").hasAuthority("SCOPE_contacts")
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_messages")
                .anyRequest().authenticated()
                .and()
            .oauth2ResourceServer()
                .jwt();
    }
}
```

或者类似于方法安全性：

```java
@PreAuthorize("hasAuthority('SCOPE_messages')")
public List<Message> getMessages(...) {}
```

#### Extracting Authorities Manually

但是，在许多情况下，此默认值不足。例如，某些授权服务器不使用scope属性，而是拥有自己的自定义属性。或者，在其他时候，资源服务器可能需要使属性或属性的组合适应内部化的权限。

为此，DSL公开了jwtAuthenticationConverter（）:

```java
@EnableWebSecurity
public class DirectlyConfiguredJwkSetUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests()
                .anyRequest().authenticated()
                .and()
            .oauth2ResourceServer()
                .jwt()
                    .jwtAuthenticationConverter(grantedAuthoritiesExtractor());
    }
}

Converter<Jwt, AbstractAuthenticationToken> grantedAuthoritiesExtractor() {
    return new GrantedAuthoritiesExtractor();
}
```

负责将Jwt转换为身份验证。

我们可以简单地重写这一点来改变授予权限的方式：

```java
static class GrantedAuthoritiesExtractor extends JwtAuthenticationConverter {
    protected Collection<GrantedAuthorities> extractAuthorities(Jwt jwt) {
        Collection<String> authorities = (Collection<String>)
                jwt.getClaims().get("mycustomclaim");

        return authorities.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}
```

为了获得更大的灵活性，DSL支持完全用任何实现Converter <Jwt，AbstractAuthenticationToken>的类替换转换器：

```java
static class CustomAuthenticationConverter implements Converter<Jwt, AbstractAuthenticationToken> {
    public AbstractAuthenticationToken convert(Jwt jwt) {
        return new CustomAuthenticationToken(jwt);
    }
}
```

####  6.8.6 Configuring Validation

使用最小的Spring Boot配置，指示授权服务器的颁发者uri，Resource Server将默认验证iss声明以及exp和nbf时间戳声明。

在需要自定义验证的情况下，Resource Server附带两个标准验证器，并且还接受自定义OAuth2TokenValidator实例。

#### Customizing Timestamp Validation

JWT通常有一个有效窗口，nbf声明中指示的窗口的开始和exp声明中指示的结尾。

但是，每个服务器都可能遇到时钟漂移，这可能导致令牌过期到一个服务器，但不会到另一个服务器。随着协作服务器数量在分布式系统中的增加，这可能会导致一些实施灼伤。

资源服务器使用JwtTimestampValidator来验证令牌的有效性窗口，并且可以使用clockSkew配置它以缓解上述问题：

```java
@Bean
JwtDecoder jwtDecoder() {
     NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)
             JwtDecoders.withOidcIssuerLocation(issuerUri);

     OAuth2TokenValidator<Jwt> withClockSkew = new DelegatingOAuth2TokenValidator<>(
            new JwtTimestampValidator(Duration.ofSeconds(60)),
            new IssuerValidator(issuerUri));

     jwtDecoder.setJwtValidator(withClockSkew);

     return jwtDecoder;
}
```

> 默认情况下，资源服务器配置30秒的时钟偏差。

####  Configuring a Custom Validator

使用OAuth2TokenValidator API添加对aud声明的检查很简单：

```java
public class AudienceValidator implements OAuth2TokenValidator<Jwt> {
    OAuth2Error error = new OAuth2Error("invalid_token", "The required audience is missing", null);

    public OAuth2TokenValidatorResult validate(Jwt jwt) {
        if (jwt.getAudience().contains("messaging")) {
            return OAuth2TokenValidatorResult.success();
        } else {
            return OAuth2TokenValidatorResult.failure(error);
        }
    }
}
```

然后，要添加到资源服务器，需要指定JwtDecoder实例：

```java
@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)
        JwtDecoders.withOidcIssuerLocation(issuerUri);

    OAuth2TokenValidator<Jwt> audienceValidator = new AudienceValidator();
    OAuth2TokenValidator<Jwt> withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri);
    OAuth2TokenValidator<Jwt> withAudience = new DelegatingOAuth2TokenValidator<>(withIssuer, audienceValidator);

    jwtDecoder.setJwtValidator(withAudience);

    return jwtDecoder;
}
```

#### 6.8.7 Configuring Claim Set Mapping

Spring Security使用[Nimbus](https://bitbucket.org/connect2id/nimbus-jose-jwt/wiki/Home) 库来解析JWT并验证其签名。因此，Spring Security受Nimbus对每个字段值的解释以及如何将每个字段强制转换为Java类型。

例如，因为Nimbus与Java 7兼容，所以它不使用Instant来表示时间戳字段。

并且完全可以使用不同的库或JWT处理，这可能会使自己的强制决策需要调整。

或者，很简单，资源服务器可能希望根据特定域的原因添加或删除JWT中的声明。

出于这些目的，Resource Server支持使用MappedJwtClaimSetConverter映射JWT声明集。

#### Customizing the Conversion of a Single Claim

默认情况下，MappedJwtClaimSetConverter将尝试将声明强制转换为以下类型:

| Claim | Java Type            |
| ----- | -------------------- |
| `aud` | `Collection<String>` |
| `exp` | `Instant`            |
| `iat` | `Instant`            |
| `iss` | `String`             |
| `jti` | `String`             |
| `nbf` | `Instant`            |
| `sub` | `String`             |

可以使用MappedJwtClaimSetConverter.withDefaults配置单个声明的转换策略：

```java
@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = new NimbusJwtDecoder(JwtProcessors.withJwkSetUri(jwkSetUri).build());

    MappedJwtClaimSetConverter converter = MappedJwtClaimSetConverter
            .withDefaults(Collections.singletonMap("sub", this::lookupUserIdBySub));
    jwtDecoder.setClaimSetConverter(converter);

    return jwtDecoder;
}
```

这将保留所有默认值，但它将覆盖sub的默认声明转换器。

####  Adding a Claim

MappedJwtClaimSetConverter还可用于添加自定义声明，例如，以适应现有系统：

```java
MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap("custom", custom -> "value"));
```

#### Removing a Claim

使用相同的API删除声明也很简单：

```java
MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap("legacyclaim", legacy -> null));
```

####  Renaming a Claim

在更复杂的场景中，例如一次查询多个声明或重命名声明，Resource Server接受任何实现`Converter<Map<String, Object>, Map<String,Object>>`:的类：

```java
public class UsernameSubClaimAdapter implements Converter<Map<String, Object>, Map<String, Object>> {
    private final MappedJwtClaimSetConverter delegate =
            MappedJwtClaimSetConverter.withDefaults(Collections.emptyMap());

    public Map<String, Object> convert(Map<String, Object> claims) {
        Map<String, Object> convertedClaims = this.delegate.convert(claims);

        String username = (String) convertedClaims.get("user_name");
        convertedClaims.put("sub", username);

        return convertedClaims;
    }
}
```

然后，可以像平常一样提供实例：

```java
@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = new NimbusJwtDecoder(JwtProcessors.withJwkSetUri(jwkSetUri).build());
    jwtDecoder.setClaimSetConverter(new UsernameSubClaimAdapter());
    return jwtDecoder;
}
```

####  6.8.8 Configuring Timeouts

默认情况下，Resource Server使用每个30秒的连接和套接字超时来协调授权服务器。

在某些情况下，这可能太短。此外，它没有考虑更复杂的模式，如退避和发现。

要调整Resource Server连接到授权服务器的方式，NimbusJwtDecoder接受RestOperations的实例：

```java
@Bean
public JwtDecoder jwtDecoder(RestTemplateBuilder builder) {
    RestOperations rest = builder
            .setConnectionTimeout(60000)
            .setReadTimeout(60000)
            .build();

    NimbusJwtDecoder jwtDecoder = new NimbusJwtDecoder(JwtProcessors.withJwkSetUri(jwkSetUri).restOperations(rest).build());
    return jwtDecoder;
}
```

---

### 6.9 Authentication

到目前为止，我们只看了最基本的身份验证配置。我们来看一些稍微更高级的配置身份验证选项。

#### 6.9.1 In-Memory Authentication

我们已经看到了为单个用户配置内存中身份验证的示例。以下是配置多个用户的示例：

```java
@Bean
public UserDetailsService userDetailsService() throws Exception {
    // ensure the passwords are encoded properly
    UserBuilder users = User.withDefaultPasswordEncoder();
    InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
    manager.createUser(users.username("user").password("password").roles("USER").build());
    manager.createUser(users.username("admin").password("password").roles("USER","ADMIN").build());
    return manager;
}
```

####  6.9.2 JDBC Authentication

您可以找到支持基于JDBC的身份验证的更新。以下示例假定您已在应用程序中定义了DataSource.jdbc-[jdbc-javaconfig](https://github.com/spring-projects/spring-security/tree/master/samples/javaconfig/jdbc) 示例提供了使用基于JDBC的身份验证的完整示例。

```java
@Autowired
private DataSource dataSource;

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
    // ensure the passwords are encoded properly
    UserBuilder users = User.withDefaultPasswordEncoder();
    auth
        .jdbcAuthentication()
            .dataSource(dataSource)
            .withDefaultSchema()
            .withUser(users.username("user").password("password").roles("USER"))
            .withUser(users.username("admin").password("password").roles("USER","ADMIN"));
}
```

#### 6.9.3 LDAP Authentication

您可以找到支持基于LDAP的身份验证的更新.[ldap-javaconfig](https://github.com/spring-projects/spring-security/tree/master/samples/javaconfig/ldap) 示例提供了使用基于LDAP的身份验证的完整示例。

```java
@Autowired
private DataSource dataSource;

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .ldapAuthentication()
            .userDnPatterns("uid={0},ou=people")
            .groupSearchBase("ou=groups");
}
```

上面的示例使用以下LDIF和嵌入式Apache DS LDAP实例。

**users.ldif.** 

```properties
dn: ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: groups

dn: ou=people,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: people

dn: uid=admin,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Rod Johnson
sn: Johnson
uid: admin
userPassword: password

dn: uid=user,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Dianne Emu
sn: Emu
uid: user
userPassword: password

dn: cn=user,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: user
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org
uniqueMember: uid=user,ou=people,dc=springframework,dc=org

dn: cn=admin,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: admin
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org
```

#### 6.9.4 AuthenticationProvider

您可以通过将自定义AuthenticationProvider公开为bean来定义自定义身份验证。例如，假设SpringAuthenticationProvider实现AuthenticationProvider，以下将自定义身份验证：

> 仅在尚未填充AuthenticationManagerBuilder时使用此选项

```java
@Bean
public SpringAuthenticationProvider springAuthenticationProvider() {
    return new SpringAuthenticationProvider();
}
```

#### 6.9.5 UserDetailsService

您可以通过将自定义UserDetailsService公开为bean来定义自定义身份验证。例如，假设SpringDataUserDetailsService实现UserDetailsService，以下将自定义身份验证：

> 仅在尚未填充AuthenticationManagerBuilder且未定义AuthenticationProviderBean时才使用此选项。

```java
@Bean
public SpringDataUserDetailsService springDataUserDetailsService() {
    return new SpringDataUserDetailsService();
}
```

您还可以通过将PasswordEncoder作为bean公开来自定义密码的编码方式。例如，如果使用bcrypt，则可以添加bean定义，如下所示：

```java
@Bean
public BCryptPasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}
```

---

### 6.10 Multiple HttpSecurity

我们可以配置多个HttpSecurity实例，就像我们可以有多个<http>块一样。关键是多次扩展WebSecurityConfigurationAdapter。例如，以下是具有以/ api /开头的URL的不同配置的示例。

```java
@EnableWebSecurity
public class MultiHttpSecurityConfig {
    @Bean                                                             
    public UserDetailsService userDetailsService() throws Exception {
        // ensure the passwords are encoded properly
        UserBuilder users = User.withDefaultPasswordEncoder();
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(users.username("user").password("password").roles("USER").build());
        manager.createUser(users.username("admin").password("password").roles("USER","ADMIN").build());
        return manager;
    }

    @Configuration
    @Order(1)                                                        
    public static class ApiWebSecurityConfigurationAdapter extends WebSecurityConfigurerAdapter {
        protected void configure(HttpSecurity http) throws Exception {
            http
                .antMatcher("/api/**")                               
                .authorizeRequests()
                    .anyRequest().hasRole("ADMIN")
                    .and()
                .httpBasic();
        }
    }

    @Configuration                                                   
    public static class FormLoginWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                .authorizeRequests()
                    .anyRequest().authenticated()
                    .and()
                .formLogin();
        }
    }
}
```

- 正常配置身份验证
- 创建包含@Order的WebSecurityConfigurerAdapter实例，以指定应首先考虑哪个WebSecurityConfigurerAdapter
- http.antMatcher声明此HttpSecurity仅适用于以/ api /开头的URL
- 创建WebSecurityConfigurerAdapter的另一个实例。如果URL不以/ api /开头，则将使用此配置。此配置在ApiWebSecurityConfigurationAdapter之后考虑，因为它在1之后具有@Order值（没有@Order默认为last）。

---

### 6.11 Method Security

从版本2.0开始，Spring Security大大改善了对服务层方法的安全性的支持。它为JSR-250注解安全性以及框架的原始@Secured注释提供支持。从3.0开始，您还可以使用基于表达式的新注释。您可以将安全性应用于单个bean，使用intercept-methods元素来装饰bean声明，或者可以使用AspectJ样式切入点在整个服务层上保护多个bean。

#### 6.11.1 EnableGlobalMethodSecurity

我们可以在任何@Configuration实例上使用@EnableGlobalMethodSecurity注解启用基于注解的安全性。例如，以下内容将启用Spring Security的@Secured注解。

```java
@EnableGlobalMethodSecurity(securedEnabled = true)
public class MethodSecurityConfig {
// ...
}
```

然后，在方法（类或接口）上添加注释会相应地限制对该方法的访问。Spring Security的本机注释支持为该方法定义了一组属性。这些将传递给AccessDecisionManager，以便做出实际决定：

```java
public interface BankService {

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account readAccount(Long id);

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account[] findAccounts();

@Secured("ROLE_TELLER")
public Account post(Account account, double amount);
}
```

可以使用支持JSR-250注解

```java
@EnableGlobalMethodSecurity(jsr250Enabled = true)
public class MethodSecurityConfig {
// ...
}
```

这些是基于标准的，允许应用简单的基于角色的约束，但没有Spring Security的原生注解功能。要使用新的基于表达式的语法，您可以使用:

```java
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig {
// ...
}
```

等效的Java代码：

```java
public interface BankService {

@PreAuthorize("isAnonymous()")
public Account readAccount(Long id);

@PreAuthorize("isAnonymous()")
public Account[] findAccounts();

@PreAuthorize("hasAuthority('ROLE_TELLER')")
public Account post(Account account, double amount);
}
```

#### 6.11.2 GlobalMethodSecurityConfiguration

有时您可能需要执行比@EnableGlobalMethodSecurity注解允许更复杂的操作。对于这些实例，您可以扩展GlobalMethodSecurityConfiguration，确保子类上存在@EnableGlobalMethodSecurity注解。例如，如果要提供自定义MethodSecurityExpressionHandler，可以使用以下配置：

```java
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
    @Override
    protected MethodSecurityExpressionHandler createExpressionHandler() {
        // ... create and return custom MethodSecurityExpressionHandler ...
        return expressionHandler;
    }
}
```

有关可以覆盖的方法的其他信息，请参阅GlobalMethodSecurityConfiguration Javadoc。

---

###  6.12 Post Processing Configured Objects

Spring Security的Java配置不会公开它配置的每个对象的每个属性。这简化了大多数用户的配置。毕竟，如果每个属性都被暴露，用户可以使用标准bean配置。

虽然有充分的理由不直接公开每个属性，但用户可能仍需要更高级的配置选项。为了解决这个问题，Spring Security引入了ObjectPostProcessor的概念，该概念可用于修改或替换Java Configuration创建的许多Object实例。

例如，如果要在FilterSecurityInterceptor上配置filterSecurityPublishAuthorizationSuccess属性，可以使用以下命令：

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .anyRequest().authenticated()
            .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {
                public <O extends FilterSecurityInterceptor> O postProcess(
                        O fsi) {
                    fsi.setPublishAuthorizationSuccess(true);
                    return fsi;
                }
            });
}
```

---

### 6.13 Custom DSLs

您可以在Spring Security中提供自己的自定义DSL。例如，您可能会看到如下内容：

```java
public class MyCustomDsl extends AbstractHttpConfigurer<MyCustomDsl, HttpSecurity> {
    private boolean flag;

    @Override
    public void init(H http) throws Exception {
        // any method that adds another configurer
        // must be done in the init method
        http.csrf().disable();
    }

    @Override
    public void configure(H http) throws Exception {
        ApplicationContext context = http.getSharedObject(ApplicationContext.class);

        // here we lookup from the ApplicationContext. You can also just create a new instance.
        MyFilter myFilter = context.getBean(MyFilter.class);
        myFilter.setFlag(flag);
        http.addFilterBefore(myFilter, UsernamePasswordAuthenticationFilter.class);
    }

    public MyCustomDsl flag(boolean value) {
        this.flag = value;
        return this;
    }

    public static MyCustomDsl customDsl() {
        return new MyCustomDsl();
    }
}
```

> 这实际上是如何实现像HttpSecurity.authorizeRequests（）这样的方法。

然后可以像这样使用自定义DSL：

```java
@EnableWebSecurity
public class Config extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .apply(customDsl())
                .flag(true)
                .and()
            ...;
    }
}
```

代码按以下顺序调用：

- Code in `Config`s configure method is invoked
- Code in `MyCustomDsl`s init method is invoked
- Code in `MyCustomDsl`s configure method is invoked

如果需要，可以使用SpringFactories默认添加WebSecurityConfiguerAdapter添加MyCustomDsl。例如，您将在名为META-INF / spring.factories的类路径上创建一个具有以下内容的资源：

**META-INF/spring.factories.** 

```properties
org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer = sample.MyCustomDsl
```

希望禁用默认值的用户可以明确地这样做。

```java
@EnableWebSecurity
public class Config extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .apply(customDsl()).disable()
            ...;
    }
}
```